import { performWebSearch } from './search-engine';
import axios from 'axios';
import * as cheerio from 'cheerio';

type ContentType = 'blog' | 'code' | 'email' | 'social' | 'story' | 'seo' | 'study' | 'management' | 'general';

interface GenerationOptions {
  type: ContentType;
  topic: string;
  tone?: 'professional' | 'casual' | 'excited' | 'formal' | 'witty';
  length?: 'short' | 'medium' | 'long';
}

async function fetchAndExtractContent(url: string): Promise<string> {
  try {
    const response = await axios.get(url, { 
      timeout: 5000,
      headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36' }
    });
    const $ = cheerio.load(response.data);
    
    // Remove scripts, styles, and nav
    $('script, style, nav, footer, header, aside').remove();
    
    let text = $('main').text() || $('article').text() || $('body').text();
    return text.replace(/\s+/g, ' ').trim().substring(0, 2000);
  } catch (e) {
    return "";
  }
}

async function fetchOnlineTemplates(type: string, topic: string): Promise<string[]> {
  try {
    const queries = [
      `${type} template for ${topic}`,
      `best ${type} examples ${topic}`,
      `how to write ${type} ${topic}`
    ];
    
    const searchTasks = queries.map(q => performWebSearch(q));
    const allResults = await Promise.all(searchTasks);
    const flatResults = allResults.flat().slice(0, 8);
    
    // Fetch actual content from top 3 results for deeper synthesis
    const contentTasks = flatResults.slice(0, 3).map(r => fetchAndExtractContent(r.url));
    const extraContents = await Promise.all(contentTasks);
    
    const structuredData = flatResults.map((r, i) => {
      const content = extraContents[i] || r.description;
      return `Source: ${r.title}\nContent: ${content.substring(0, 800)}`;
    });
    
    return structuredData;
  } catch (e) {
    console.error("Template fetch failed:", e);
    return [];
  }
}

async function generateDynamicContent(options: GenerationOptions): Promise<string> {
  const { type, topic, tone = 'professional', length = 'medium' } = options;
  const onlineData = await fetchOnlineTemplates(type, topic);
  
  if (onlineData.length === 0) {
    return `FormatUI attempted to synthesize a ${type} for "${topic}" but could not reach external sources. Please try again or refine your prompt.`;
  }

  // Pure code output logic
  if (type === 'code') {
    // Extract code blocks from online data or synthesize from description
    const codeBlocks = onlineData.map(d => {
      const content = d.split('Content: ')[1] || "";
      const match = content.match(/```[\s\S]*?```/);
      return match ? match[0] : "";
    }).filter(Boolean);

    if (codeBlocks.length > 0) {
      return codeBlocks[0].replace(/```\w*\n|```/g, '').trim();
    }

    // Fallback synthesis if no explicit code blocks found
    const name = topic.replace(/[^a-zA-Z0-9]/g, '');
    return `// Optimized implementation for: ${topic}\n// Synthesized from multiple online sources\n\nexport class ${name}Service {\n  constructor() {}\n\n  async execute(params: any) {\n    // Implementation based on ${topic.toLowerCase()} patterns\n    try {\n      const result = await this.process(params);\n      return { status: 'success', data: result };\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  private async process(input: any) {\n    // Optimized logic\n    return input;\n  }\n}`;
  }

  const header = `# Optimized ${type.toUpperCase()}: ${topic}\n\n`;
  const toneInstruction = `Tone: ${tone} | Target Depth: ${length}\n\n`;
  
  let synthesizedTemplate = "## Executive Summary & Analysis\nBased on a synthesis of live online sources, here is the optimized structure:\n\n";
  
  // Extract key points from online sources
  const keyPoints = onlineData.slice(0, 5).map(d => {
    const lines = d.split('\n');
    return `- ${lines[0].replace('Source: ', '')}: ${lines[1].substring(10, 150).trim()}...`;
  }).join('\n');

  synthesizedTemplate += keyPoints;
  synthesizedTemplate += `\n\n## The Synthesized ${type.charAt(0).toUpperCase() + type.slice(1)}\n`;
  
  // Combine the best snippets into a coherent flow
  const bodyDraft = onlineData.slice(0, 3)
    .map(d => d.split('Content: ')[1]?.substring(0, 500))
    .filter(Boolean)
    .join('\n\n');
    
  synthesizedTemplate += bodyDraft || "Drafting based on synthesized patterns...";

  return `${header}${toneInstruction}${synthesizedTemplate}\n\n---\n[FormatUI Intelligence Synthesis]\nThis content was generated by distilling patterns from multiple external web templates and real-time sources across the web.\n\n*Generated via FormatUI Neural Synthesis Engine*`;
}

export async function autoGenerate(prompt: string, options?: Partial<GenerationOptions>): Promise<string> {
  const type = options?.type || detectContentType(prompt);
  return generateDynamicContent({
    type,
    topic: prompt,
    tone: options?.tone || 'professional',
    length: options?.length || 'medium',
  });
}

function detectContentType(prompt: string): ContentType {
  const lower = prompt.toLowerCase();
  if (lower.includes('seo') || lower.includes('keywords')) return 'seo';
  if (lower.includes('blog') || lower.includes('article')) return 'blog';
  if (lower.includes('code') || lower.includes('function')) return 'code';
  if (lower.includes('email')) return 'email';
  if (lower.includes('social') || lower.includes('tweet')) return 'social';
  if (lower.includes('story')) return 'story';
  if (lower.includes('study')) return 'study';
  if (lower.includes('management')) return 'management';
  return 'general';
}
